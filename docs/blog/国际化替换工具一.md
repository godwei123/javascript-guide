---
create_time: 2024-06-22 00:49:32
---

# 国际化替换工具 - 背景和方案分析

> 国际化需求，对于已经存在的代码进行国际化，通常需要将代码中的中文替换为 key。此过程繁琐，而且容易出错，因此希望有个工具可以帮助我们提取代码中的中文，然后生成 key 变量，帮助我们进行国际化。

## 思路 1：正则表达式

通过正则表达式匹配中文，然后替换为 key 变量。

```js
const content = fs.readFileSync(filePath, { encoding: "utf-8" });

const reg = /'([\u4e00-\u9fa5]+)'/g;
const result = content.replace(reg, (match, p1) => {
  return `i18n.t('${key}')`;
});
```

::: info 不足点

- 正则表达式匹配中文不够准确，虽然可以调整正则表达式，但是复杂度提高，并且难以完全适用所有情况。
- 对于 html 中的替换不够准确，例如 vue 文件中的 template 部分，需要考虑加`{{key}}`。
  :::

## 思路 2：AST

babel 提供了对代码的解析和生成，可以使用 babel 解析代码，然后遍历 AST，替换中文。

```js
import parser from "@babel/parser";
import traverse from "@babel/traverse";
import generator from "@babel/generator";

const content = fs.readFileSync(filePath, { encoding: "utf-8" });

const ast = parser.parse(content, {
  sourceType: "script",
  plugins: ["jsx", "typescript"],
});

traverse(ast, {
  StringLiteral(path) {
    if (/[\u4e00-\u9fa5]/.test(path.node.value)) {
      path.node.value = `i18n.t('${key}')`;
    }
  },
});

const { code } = generator(ast);
```

通过 AST 我们可以获取每个节点的信息，然后根据节点的类型进行处理，具有很好的扩展性和灵活性，能够处理复杂代码。因此选择方案二实现工具。

## 需求分析

- 前段项目中我们通常有以下文件，包括 `.js`、`.ts`、`.jsx`、`.tsx`、`.vue` 文件
- 中文和英文混合也需要能够提取出来。
- vue 文件中的 template 部分需要提取出来，需要考虑加`{{key}}`。
- vue 文件中的标签属性替换需要加冒号，例如 `:attr="t('key')"`。

## 替换方案设计

::: tip
对于 `.js`、`.ts`、`.jsx`、`.tsx` 文件，我们可以使用 `babel` 插件进行处理解析。
对于 `.vue` 文件，我们可以使用 vue 的 `@vue/compiler-sfc` 工具解析。
:::

1、解析 JSX

babel 插件包已提供了对 jsx 语法的解析 `@babel/plugin-syntax-jsx`

```js
import babel from "@babel/core";
import pluginSyntaxJSX from "@babel/plugin-syntax-jsx";

babel.parseSync(code, {
  plugins: [pluginSyntaxJSX],
});
```

2、解析 TS

babel 插件包已提供了对 typescript 语法的解析 `@babel/preset-typescript`

```js
import babel from "@babel/core";
import pluginSyntaxJSX from "@babel/preset-typescript";

babel.parseSync(code, {
  plugins: [presetTypescript, { isTSX: true, allExtensions: true }],
});
```

3、解析 Vue

使用 vue 官方提供的@vue/compiler-sfc 工具。其中 css 可以跳过直接用源码，js 部分依然用 babel 处理，html 部分我们可以使用 htmlparser2 工具解析。

```js
import { parse } from "@vue/compiler-sfc";
const { descriptor, errors } = parse(code);
const { template, script, scriptSetup, styles } = descriptor;
```

4、htmlparser2

> [htmlparser2](https://github.com/fb55/htmlparser2) 是一个解析 html 的工具，可以解析 html 字符串，生成 dom 树。

```js
import * as htmlparser2 from "htmlparser2";

const parser = new htmlparser2.Parser({
  onopentag(name, attributes) {
    /*
     * This fires when a new tag is opened.
     *
     * If you don't need an aggregated `attributes` object,
     * have a look at the `onopentagname` and `onattribute` events.
     */
    if (name === "script" && attributes.type === "text/javascript") {
      console.log("JS! Hooray!");
    }
  },
  ontext(text) {
    /*
     * Fires whenever a section of text was processed.
     *
     * Note that this can fire at any point within text and you might
     * have to stitch together multiple pieces.
     */
    console.log("-->", text);
  },
  onclosetag(tagname) {
    /*
     * Fires when a tag is closed.
     *
     * You can rely on this event only firing when you have received an
     * equivalent opening tag before. Closing tags without corresponding
     * opening tags will be ignored.
     */
    if (tagname === "script") {
      console.log("That's it?!");
    }
  },
});
```

5、遍历 AST

babel 工具我们可以很方便的在遍历的过程中对每个节点进行处理，当节点中发现中文时，使用 babel 重新生成新的节点进行替换即可。

```js
traverse(ast, {
  enter() {
    // 判断是否跳过i18n转换
  },

  StringLiteral() {
    // 处理字符串里的中文
  },

  TemplateLiteral() {
    // 处理模板字符串里的中文
  },

  JSXText() {
    // 处理jsx文本节点里的中文
  },

  JSXAttribute() {
    // 处理jsx属性里的中文
  },

  CallExpression() {
    // 处理表达式里的中文
  },

  ImportDeclaration() {
    // 根据配置加入导入声明
  },
});
```

在遍历的过程中，我们可以顺便将中文以保存到文件中，以便后续翻译。

6、生成新的代码

在遍历 AST 的过程中，我们可以使用 babel 提供的 generator 工具生成新的代码。

```js
const { code } = generator(ast);
```

## 工具设计与实现

[国际化替换工具二.md](%E5%9B%BD%E9%99%85%E5%8C%96%E6%9B%BF%E6%8D%A2%E5%B7%A5%E5%85%B7%E4%BA%8C.md)
