---
create_time: 2024-08-23 23:32:47
---

# 图标组件库学习

> 使用 AI 工具 MarsCode 学习开源代码，本文档学习图标组件库的设计和实现。

::: tip
图标组件库打包可以同时生成多个版本的组件库，比如 React、Vue、Flutter 等。生成 esm、cjs、umd 等多个版本。

IconPark：https://github.com/bytedance/IconPark

IconSpace：https://github.com/icon-space/IconSpace

iconoir：https://github.com/iconoir-icons/iconoir

IconSpace 本项目是由 IconPark 派生而来，在此基础上进行改造和扩充。
:::

## Generator(createVueNextGenerator -- JSXGenerator)

```ts
import { IGeneratorOptions } from "../Generator";
import { ISvgAttr, ISvgElementInfo, ISvgInfo, ISvgInlineStyleAttr, SvgShapeAttr } from "../types";
import { pascalCase } from "../util";
import { IconGenerator } from "./IconGenerator";

export interface IReactGeneratorOptions extends IGeneratorOptions {
  // 是否使用默认导出
  useDefault?: boolean;

  // 是否导出类型
  useType?: boolean;

  // 是否使用JSX, helper
  useHelper?: boolean;

  // 是否需要给Wrapper传递Name
  wrapperNeedName?: boolean;

  // 是否需要编译RTL属性
  wrapperNeedRTL?: boolean;

  // 是否导出style
  style?: boolean;

  // 当前组件在rtl时是否需要翻转
  rtl?: boolean;

  // JSX helper名字
  helperName?: string;

  // 属性的名字，默认'props'
  propName?: string;

  // 样式属性名称，默认'props'
  stylePropName?: string;

  // 引用路径
  importPath?: string;

  // 额外的引用路径
  extraImport?: string[];
}

export class JSXGenerator extends IconGenerator {
  protected useDefault: boolean;
  protected useType: boolean;
  protected style: boolean;
  protected useHelper: boolean;
  protected helperName: string;
  protected propName: string;
  protected stylePropName: string;
  protected wrapperNeedName: boolean;
  protected importPath: string;
  protected extraImport: string[];
  protected rtl: boolean;
  protected wrapperNeedRTL: boolean;

  constructor(options: IReactGeneratorOptions) {
    super(options);

    this.useDefault = options.useDefault || false;
    this.useType = options.useType || false;
    this.style = options.style || false;
    this.useHelper = options.useHelper || false;
    this.helperName = options.helperName || "h";
    this.propName = options.propName || "props";
    this.stylePropName = options.stylePropName || "props";
    this.wrapperNeedName = options.wrapperNeedName || false;
    this.extraImport = options.extraImport || [];
    this.importPath = options.importPath || "../runtime";
    this.rtl = options.rtl || false;
    this.wrapperNeedRTL = options.wrapperNeedRTL || false;
  }

  // eslint-disable-next-line max-statements
  public process(info: ISvgInfo): string {
    const {
      useDefault,
      useType,
      style,
      useHelper,
      helperName,
      propName,
      stylePropName,
      wrapperNeedName,
      wrapperNeedRTL,
      rtl,
      importPath,
      extraImport,
    } = this;

    this.processHeaderComment();
    this.writeLine("// @ts-nocheck");
    this.writeLine("/* tslint:disable: max-line-length */");
    this.writeLine("/* eslint-disable max-len */");

    if (extraImport.length) {
      extraImport.forEach((item) => this.writeLine(item));
    }

    // 处理顶部引用import {IIconType, IconWrapper} from '../components/icon'
    this.write("import");
    this.space();
    this.write("{");

    const imports: string[] = [];
    const typeName = this.getInterfaceName("props", true);
    const wrapperName = this.getTypeName("wrapper");

    if (useType) {
      imports.push(typeName);

      if (useHelper) {
        imports.push(this.getTypeName("helper"));
      }
    }

    imports.push(wrapperName);
    this.write(imports.join(", "));
    this.write("}");
    this.space();
    this.write("from");
    this.space();
    this.write("'");
    this.write(importPath);
    this.writeLine("';");
    this.writeLine();

    // 处理顶部导出
    this.write("export");
    this.space();

    if (useDefault) {
      this.write("default");
      this.space();
    }

    // 处理const Name = IConWrapper(xxx)/IConWrapper(xxx)
    if (!useDefault) {
      this.write("const");
      this.space();
      this.write(pascalCase(this.name));
      this.space();
      this.write("=");
      this.space();
    }

    this.write(wrapperName);
    this.writeLine("(");
    this.indent(1);

    if (wrapperNeedName) {
      this.write("'");
      this.write(this.name);
      this.write("'");
      this.writeLine(",");
    }

    if (wrapperNeedRTL) {
      this.write(String(rtl));
      this.writeLine(",");
    }

    // 处理函数参数：(props: IIconProps)
    this.write("(");

    if (useHelper) {
      this.write(helperName);

      if (useType) {
        this.write(": ");
        this.write(this.getTypeName("helper"));
      }

      this.write(",");
      this.space();
    }

    this.write(propName);

    if (useType) {
      this.write(":");
      this.space();
      this.write(typeName);
    }

    this.write(")");
    this.space();

    // wrapper用箭头函数
    this.write("=>");
    this.space();
    this.writeLine("(");
    this.indent(1);
    this.processTag(info.element);
    this.indent(-1);
    this.write(")");

    if (style) {
      this.writeLine(",");
      this.write("(");
      this.write(stylePropName);

      if (useType) {
        this.write(": ");
        this.write(typeName);
      }

      this.write(")");
      this.write(" => ");
      this.processStyle(info.style);
      this.writeLine();
    } else {
      this.writeLine();
    }

    this.indent(-1);
    this.writeLine(");");

    return this.getResult();
  }

  public processTag(info: ISvgElementInfo): void {
    const { type, attrs, style, children } = info;
    this.write("<");
    this.write(type);

    attrs.forEach((item) => this.processAttr(item));

    if (style.length) {
      this.processInlineStyle(style);
    }

    if (attrs.length) {
      this.writeLine();
    }

    if (children.length) {
      this.writeLine(">");
      this.indent(1);
      children.forEach((item) => this.processTag(item));
      this.indent(-1);
      this.writeLine("</" + info.type + ">");
    } else {
      this.writeLine("/>");
    }
  }

  protected processAttr(attr: ISvgAttr): void {
    const { name, type, expression } = attr;
    this.writeLine("");
    this.indent(1);
    this.write(name);
    this.write("=");
    if (type === SvgShapeAttr.DYNAMIC) {
      this.write("{");
      this.write(expression);
      this.write("}");
    } else {
      this.write('"');
      this.write(expression);
      this.write('"');
    }
    this.indent(-1);
  }

  private processInlineStyle(exp: ISvgInlineStyleAttr[]): void {
    this.write(" style={{");

    exp.forEach(({ name, expression, type }, index) => {
      this.write(name);
      this.write(":");
      this.space();

      if (type === SvgShapeAttr.DYNAMIC) {
        this.write(expression);
      } else {
        const nv = +expression;

        if (Number.isNaN(nv)) {
          this.write("'");
          this.write(expression.replace(/'/g, "\\'"));
          this.write("'");
        } else {
          this.write(expression);
        }
      }

      if (index !== exp.length - 1) {
        this.write(",");
        this.space();
      }
    });

    this.write("}}");
  }
}
```

## compiler

> 编译函数，将 svg 字符串编译成想要内容

```ts
import { Generator } from "./Generator";
import { Parser } from "./Parser";
import { ITransformPlugin, Transformer } from "./Transformer";

export interface ICompilerOptions {
  content: string; // svg字符串
  plugins: ITransformPlugin[]; // 插件
  generator: Generator; // 生成器
}

/**
 * 编译函数
 *
 * @param options 配置信息
 */
export function compiler(options: ICompilerOptions): string {
  const parser = new Parser(options.content);
  const info = parser.process();
  const transformer = new Transformer({
    info,
    plugins: options.plugins,
  });

  const transformed = transformer.process(); // 处理代码

  return options.generator.process(transformed); // 根据属性写成代码，每个具体的 [icon-name].[js/ts][x]
}

export interface IColorConvertHueInfo {
  type: "hue";
  hue: number;
}
```

## Transformer

```ts
import {
  ISvgAttr,
  ISvgElementInfo,
  ISvgInfo,
  ISvgInlineStyleAttr,
  ISvgStyleAttr,
  ISvgStyleKeyframesInfo,
  ISvgStyleRuleInfo,
  ISvgStyleSelector,
  SvgTags,
} from "./types";

export interface ITransformProgramPluginItem {
  // 进入时变换，返回一个新的ISvgInfo
  enter: (elem: ISvgInfo) => ISvgInfo;
  // 退出时变换，返回一个新的ISvgInfo，与进入的区别在于，退出时所以属性和孩子都已经处理过了。
  exit: (elem: ISvgInfo) => ISvgInfo;
}

export interface ITransformPluginItem {
  // 进入时变换，返回一个新的ISvgInfo，返回null将删除节点
  enter: (elem: ISvgElementInfo) => ISvgElementInfo | null;
  // 属性变换，返回一个新的ISvgAttr，返回null将删除属性
  attr: (attr: ISvgAttr, elem: ISvgElementInfo) => ISvgAttr | null;
  // 行内样式处理，返回一个新的ISvgInlineStyleAttr，返回null将删除样式
  style: (attr: ISvgInlineStyleAttr, elem: ISvgElementInfo) => ISvgInlineStyleAttr | null;
  // 退出时变换，返回一个新的ISvgInfo，返回null将删除节点，与进入的区别在于，退出时所以属性和孩子都已经处理过了。
  exit: (elem: ISvgElementInfo) => ISvgElementInfo | null;
}

export interface IRuleTransformPluginItem {
  // 进入时变换，返回一个新的ISvgInfo，返回null将删除节点
  enter: (elem: ISvgStyleRuleInfo) => ISvgStyleRuleInfo | null;

  // 选择器变换，返回一个新的selector，返回null将删除属性
  selector: (attr: ISvgStyleSelector, elem: ISvgStyleRuleInfo) => ISvgStyleSelector | null;

  // 属性变换，返回一个新的ISvgAttr，返回null将删除属性
  attr: (attr: ISvgStyleAttr, elem: ISvgStyleRuleInfo) => ISvgStyleAttr | null;

  // 退出时变换，返回一个新的ISvgInfo，返回null将删除节点，与进入的区别在于，退出时所以属性和孩子都已经处理过了。
  exit: (elem: ISvgStyleRuleInfo) => ISvgStyleRuleInfo | null;
}

export interface IKeyframesTransformPluginItem {
  // 进入时变换，返回一个新的ISvgInfo，返回null将删除节点
  enter: (elem: ISvgStyleKeyframesInfo) => ISvgStyleKeyframesInfo | null;

  // 选择器变换，返回一个新的selector，返回null将删除属性
  selector: (attr: ISvgStyleSelector, elem: ISvgStyleKeyframesInfo) => ISvgStyleSelector | null;

  // 退出时变换，返回一个新的ISvgInfo，返回null将删除节点，与进入的区别在于，退出时所以属性和孩子都已经处理过了。
  exit: (elem: ISvgStyleKeyframesInfo) => ISvgStyleKeyframesInfo | null;
}

// 标签名
// 支持用*表示全部
export interface ITransformPlugin
  extends Partial<Record<SvgTags, Partial<ITransformPluginItem>>>,
    Partial<ITransformProgramPluginItem> {
  "*"?: Partial<ITransformPluginItem>;
  rule?: Partial<IRuleTransformPluginItem>;
  keyframes?: Partial<IKeyframesTransformPluginItem>;
}

export interface ITransformOptions {
  info: ISvgInfo;
  plugins: ITransformPlugin[];
}

export const noopTransformer = <T>(item: T): T => item;

/**
 * 转换器
 *
 * @desc 默认不进行转化
 */
export class Transformer {
  protected plugins: ITransformPlugin[];
  protected info: ISvgInfo;
  protected cache: Record<string, unknown> = {};

  constructor(options: ITransformOptions) {
    this.info = options.info;
    this.plugins = options.plugins;
  }

  // 执行的部分
  public process(): ISvgInfo {
    // 初始化插件，添加enter和exit生命周期方法
    // AEnter -> BEnter -> CEnter -> DEnter -> DExit -> CExit -> BExit -> AExit
    const plugins = this.processProgramPlugin();

    let info = this.info;

    // 正序执行进入
    for (const plugin of plugins) {
      info = plugin.enter(info);
    }

    const { element, style } = info;
    const svg = this.processElement(element);
    const keyframes = style.keyframes.map((keyframe) => this.processStyleKeyframe(keyframe));
    const rules = style.rules.map((rule) => this.processStyleRule(rule));

    if (svg == null) {
      throw new Error("svg标签不可返回空");
    }

    info = {
      element: svg,
      style: {
        keyframes: keyframes.filter((item) => !!item) as ISvgStyleKeyframesInfo[],
        rules: rules.filter((item) => !!item) as ISvgStyleRuleInfo[],
      },
    };

    // 倒序执行退出
    for (let i = plugins.length - 1; i >= 0; i--) {
      info = plugins[i].exit(info);
    }

    return info;
  }

  // 处理一个元素
  protected processElement(info: ISvgElementInfo): ISvgElementInfo | null {
    // plugin 添加各种的生命周期方法
    // enter、attr、style、exit
    const plugins = this.processTagPlugin(info.type);

    // 正序执行进入
    for (const plugin of plugins) {
      const result = plugin.enter(info);

      if (result == null) {
        return null;
      }

      info = result;
    }

    // 执行属性处理
    const newAttrs: ISvgAttr[] = [];

    info.attrs.forEach((attr) => {
      // 正序执行进入
      for (const plugin of plugins) {
        const result = plugin.attr(attr, info);

        if (result == null) {
          return;
        }

        attr = result;
      }

      newAttrs.push(attr);
    });

    info.attrs = newAttrs;

    const newStyle: ISvgInlineStyleAttr[] = [];

    info.style.forEach((attr) => {
      // 正序执行进入
      for (const plugin of plugins) {
        const result = plugin.style(attr, info);

        if (result == null) {
          return;
        }

        attr = result;
      }

      newStyle.push(attr);
    });

    info.style = newStyle;

    // 执行处理孩子
    const newChildren: ISvgElementInfo[] = [];

    info.children.forEach((child) => {
      // 更新一下父元素的引用
      child.parent = info;

      // 正序执行进入
      const result = this.processElement(child);

      if (result == null) {
        return;
      }

      newChildren.push(result);
    });

    info.children = newChildren;

    // 倒序执行退出
    for (let i = plugins.length - 1; i >= 0; i--) {
      const result = plugins[i].exit(info);

      if (result == null) {
        return null;
      }

      info = result;
    }

    return info;
  }

  private processStyleKeyframe(keyframe: ISvgStyleKeyframesInfo): ISvgStyleKeyframesInfo | null {
    const plugins = this.processStyleKeyframePlugin();

    // 正序执行进入
    for (const plugin of plugins) {
      const result = plugin.enter(keyframe);

      if (result == null) {
        return null;
      }

      keyframe = result;
    }

    // 执行属性变换
    for (const plugin of plugins) {
      const result = plugin.selector(keyframe.selector, keyframe);

      // 删除了selector和删除没区别
      if (result == null) {
        return null;
      }

      keyframe.selector = result;
    }

    const newRules: ISvgStyleRuleInfo[] = [];

    keyframe.rules.forEach((rule) => {
      const result = this.processStyleRule(rule);

      if (result == null) {
        return;
      }

      newRules.push(result);
    });

    keyframe.rules = newRules;

    // 倒序执行退出
    for (let i = plugins.length - 1; i >= 0; i--) {
      const result = plugins[i].exit(keyframe);

      if (result == null) {
        return null;
      }

      keyframe = result;
    }

    return keyframe;
  }

  private processStyleRule(rule: ISvgStyleRuleInfo): ISvgStyleRuleInfo | null {
    const plugins = this.processStyleRulePlugin();

    // 正序执行进入
    for (let plugin of plugins) {
      const result = plugin.enter(rule);

      if (result == null) {
        return null;
      }

      rule = result;
    }

    const selector = this.processStyleRuleSelector(rule.selector, rule, plugins);

    if (selector == null) {
      return null;
    }

    rule.selector = selector;

    const newAttrs: ISvgStyleAttr[] = [];

    rule.attrs.forEach((attr) => {
      let res: ISvgStyleAttr | null = attr;

      for (let plugin of plugins) {
        res = plugin.attr(res, attr.owner);

        if (res == null) {
          return null;
        }
      }

      newAttrs.push(res);
    });

    rule.attrs = newAttrs;

    // 倒序执行退出
    for (let i = plugins.length - 1; i >= 0; i--) {
      const result = plugins[i].exit(rule);

      if (result == null) {
        return null;
      }

      rule = result;
    }

    return rule;
  }

  // 插件，确定要处理那些内容
  private processTagPlugin(tag: SvgTags): ITransformPluginItem[] {
    if (this.cache[tag]) {
      return this.cache[tag] as ITransformPluginItem[];
    }

    const result: ITransformPluginItem[] = (this.cache[tag] = []);

    // 首先循环所有插件
    this.plugins.forEach((plugin) => {
      const tagPlugin = plugin[tag];
      const mapPlugin = plugin["*"];
      if (tagPlugin != null) {
        result.push({
          enter: tagPlugin.enter || noopTransformer,
          attr: tagPlugin.attr || noopTransformer,
          style: tagPlugin.style || noopTransformer,
          exit: tagPlugin.exit || noopTransformer,
        });
      }

      if (mapPlugin != null) {
        result.push({
          enter: mapPlugin.enter || noopTransformer,
          attr: mapPlugin.attr || noopTransformer,
          style: mapPlugin.style || noopTransformer,
          exit: mapPlugin.exit || noopTransformer,
        });
      }
    });

    return result;
  }

  private processStyleKeyframePlugin(): IKeyframesTransformPluginItem[] {
    if (this.cache.keyframes) {
      return this.cache.keyframes as IKeyframesTransformPluginItem[];
    }

    const result: IKeyframesTransformPluginItem[] = (this.cache.keyframes = []);

    this.plugins.forEach((item) => {
      const plugin = item.keyframes;
      if (plugin) {
        result.push({
          enter: plugin.enter || noopTransformer,
          selector: plugin.selector || noopTransformer,
          exit: plugin.exit || noopTransformer,
        });
      }
    });

    return result;
  }

  private processStyleRulePlugin(): IRuleTransformPluginItem[] {
    if (this.cache.rules) {
      return this.cache.rules as IRuleTransformPluginItem[];
    }

    const result: IRuleTransformPluginItem[] = (this.cache.rules = []);

    this.plugins.forEach((item) => {
      const plugin = item.rule;

      if (plugin) {
        result.push({
          enter: plugin.enter || noopTransformer,
          attr: plugin.attr || noopTransformer,
          selector: plugin.selector || noopTransformer,
          exit: plugin.exit || noopTransformer,
        });
      }
    });

    return result;
  }

  private processProgramPlugin(): ITransformProgramPluginItem[] {
    if (this.cache.program) {
      return this.cache.program as ITransformProgramPluginItem[];
    }

    const result: ITransformProgramPluginItem[] = (this.cache.program = []);

    this.plugins.forEach((item) => {
      result.push({
        enter: item.enter || noopTransformer,
        exit: item.exit || noopTransformer,
      });
    });

    return result;
  }

  private processStyleRuleSelector(
    selector: ISvgStyleSelector[][],
    rule: ISvgStyleRuleInfo,
    plugins: IRuleTransformPluginItem[]
  ): ISvgStyleSelector[][] | null {
    const list: ISvgStyleSelector[][] = [];

    selector.forEach((item) => {
      const result = this.processStyleRuleSelectorList(item, rule, plugins);

      // 删除了selector和删除没区别
      if (result == null) {
        return null;
      }

      list.push(result);
    });

    return list.length ? list : null;
  }

  private processStyleRuleSelectorList(
    selector: ISvgStyleSelector[],
    rule: ISvgStyleRuleInfo,
    plugins: IRuleTransformPluginItem[]
  ): ISvgStyleSelector[] | null {
    const list: ISvgStyleSelector[] = [];

    selector.forEach((item) => {
      const result = this.processStyleRuleSelectorItem(item, rule, plugins);

      // 删除了selector和删除没区别
      if (result == null) {
        return null;
      }

      list.push(result);
    });

    return list.length ? list : null;
  }

  private processStyleRuleSelectorItem(
    selector: ISvgStyleSelector,
    rule: ISvgStyleRuleInfo,
    plugins: IRuleTransformPluginItem[]
  ): ISvgStyleSelector | null {
    // 执行属性变换
    for (const plugin of plugins) {
      const result = plugin.selector(selector, rule);

      // 删除了selector和删除没区别
      if (result == null) {
        return null;
      }

      selector = result;
    }

    return selector;
  }
}

export function transform(info: ISvgInfo, plugins: ITransformPlugin[]): ISvgInfo {
  const transformer = new Transformer({
    info,
    plugins,
  });

  return transformer.process();
}
```

## 相关阅读

[图标组件库学习一.md](%E5%9B%BE%E6%A0%87%E7%BB%84%E4%BB%B6%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B8%80.md)
[图标组件库学习二.md](%E5%9B%BE%E6%A0%87%E7%BB%84%E4%BB%B6%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%BA%8C.md)
[图标组件库学习三.md](%E5%9B%BE%E6%A0%87%E7%BB%84%E4%BB%B6%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B8%89.md)
