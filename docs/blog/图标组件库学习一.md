---
create_time: 2024-08-18 14:56:27
---

# 图标组件库学习

> 使用 AI 工具 MarsCode 学习开源代码，本文档学习图标组件库的设计和实现。

::: tip
图标组件库打包可以同时生成多个版本的组件库，比如 React、Vue、Flutter 等。生成 esm、cjs、umd 等多个版本。

IconPark：https://github.com/bytedance/IconPark

IconSpace：https://github.com/icon-space/IconSpace

iconoir：https://github.com/iconoir-icons/iconoir

IconSpace 本项目是由 IconPark 派生而来，在此基础上进行改造和扩充。
:::

## IconPark 目录结构

```shell
tree -d -I node_modules
.
├── build # 构建脚本(重点)
├── packages # 组件库, React、Vue、Vue3、SVG
│   ├── react
│   │   ├── LICENSE
│   │   ├── README.md
│   │   ├── README.zh-CN.md
│   │   ├── icons.json
│   │   ├── package.json
│   │   ├── src
│   │   │   ├── all.ts
│   │   │   ├── icons # 图标，自动生成的文件
│   │   │   │   ├── DEFAULT_ICON_CONFIGS.ts
│   │   │   │   ├── xxx.tsx
│   │   │   │   └── ......
│   │   │   ├── sidebar.ts # 自动生成的文件
│   │   │   ├── map.ts # 自动生成的文件
│   │   │   └── runtime # 运行时
│   │   │       └── index.less # 样式，自动生成的文件
│   │   │       └── index.tsx # 组件，自动生成的文件
│   │   └── tsconfig.json
│   ├── svg
│   │   └── src
│   │       ├── icons
│   │       └── runtime
│   ├── vue
│   │   └── src
│   │       ├── icons
│   │       └── runtime
│   └── vue-next
│       └── src
│           ├── icons
│           └── runtime
├── source # 图标源文件
│   ├── Abstract
│   ├── Animals
│   ├── Arrows
│   ├── ......
│   ├── db.csv
│   ├── db-fixed.csv
│   ├── icons.json
│   ├── icons-config.json
│── types
│   └── gulp-babel
├── gulpfile.ts
├── lerna.json
├── package.json
├── scripts.json
├── tsconfig.json
└── yarn.lock
├── CHANGELOG.en-US.md
├── CHANGELOG.zh-CN.md
├── LICENSE
├── README.md
├── README.zh-CN.md
```

## package.json

```json
{
  "name": "iconpark",
  "private": true,
  "version": "1.0.0",
  "scripts": {
    "scripts": "better-scripts",
    "compiler:icons": "ts-node build/build-icons.ts",
    "compiler:code": "ts-node build/build-code.ts",
    "compiler:git": "git add ./packages/*",
    "compiler:clean": "rm -rf packages/*/src/runtime packages/*/src/sidebar.ts packages/*/src/icons",
    "compiler": "npm run compiler:clean && npm run compiler:icons && npm run compiler:code && npm run compiler:git",
    "build:clean": "rm -rf packages/*/lib packages/*/es packages/*/styles",
    "build:source": "gulp",
    "build:prepare": "npm run build:clean && npm run build:source",
    "publish:lerna": "lerna publish --skip-temp-tag --registry=https://registry.npmjs.org",
    "publish:all": "npm run build:prepare && npm run publish:lerna && npm run build:clean"
  },
  "dependencies": {
    "@icon-park/compiler": "^1.0.7",
    "@types/react": "^16.14.4",
    "alias-for-vue3": "npm:vue@^3.2.6",
    "vue": "^2.6.12"
  },
  "devDependencies": {
    "better-scripts": "^0.1.2",
    "csv-parse": "^4.15.1",
    "csv-stringify": "^5.6.1",
    "gulp": "^4.0.2",
    "gulp-babel": "^8.0.0",
    "gulp-less": "^4.0.1",
    "gulp-minify-css": "^1.2.4",
    "gulp-rename": "^2.0.0",
    "gulp-replace": "^1.1.3",
    "gulp-typescript": "^6.0.0-alpha.1",
    "lerna": "~3.16.5"
  }
}
```

预处理：

- `compiler:icons`：生成图标组件
- `compiler:code`：生成代码
- `compiler:git`：提交代码
- `compiler:clean`：清理文件
- `compiler`：生成图标组件、代码、提交代码

编译：

- `build:clean`：清理文件
- `build:source`：构建源文件
- `build:prepare`：准备构建
- `publish:lerna`：发布 lerna
- `publish:all`：发布所有

## build

### 1、build/build-icons.ts

> 遍历 svg 文件夹，获取文件的信息，生成想要的数据格式。

db.csv

```text

Name-CN,Name-EN,图标分类-CN,图标分类-EN,动效图标,图标预览,LTR,图标标签,UI 设计负责人
拐杖,a-cane,服饰,Clothes,,image.png,是,工具，登山杖，拐杖，木棍,马玉欣
腹部,abdominal,医疗健康,Health,,image.png,否,肚子，腹，腰,常留留
异常,abnormal,办公文档,Office,,image.png,是,报错，提示，提醒,田婧
飞机加速,acceleration,交通旅游,Travel,,image.png,是,加速，加速度，超音速，快速，飞行气流,张文珠
接受邮件,accept-email,办公文档,Office,,image.png,是,邮件，收件箱，转发邮件，回复邮件,齐奉飞
```

**输入**: source 文件夹(db.csv, source 文件夹下的 svg 文件)

**输出**: source/icons.json; source/icons-config.json; source/db-fixed.csv

```typescript
/**
 * @file build-icons
 */

import parse from "csv-parse/lib/sync";
import csv from "csv-stringify/lib/sync";
import fs from "fs";
import path from "path";

interface IIconProps {
  id: number;
  title: string;
  name: string;
  svg?: string;
  tag: string[];
  category: string;
  categoryCN: string;
  author: string;
  rtl: boolean;
}

const ICON_CSV = path.resolve(__dirname, "../source/db.csv"); // 图标csv文件
const content = fs.readFileSync(ICON_CSV, "utf8"); // 读取csv文件
const arr: string[][] = parse(content); // 解析csv文件
const map: { [key: string]: boolean } = {}; // 图标名字map
let count = 0;
let errors: { [key: string]: boolean } = {}; // 错误图标

const ALL_ICON_MAP: Record<string, [string, string]> = {}; // 所有图标map

// 首先使用 arr.slice(1) 来创建一个新的数组，该数组包含 arr 中从索引为 1 的元素开始的所有元素。
const NEW_CSV: string[][] = arr.slice(0, 1); // 新的csv文件

// 读取所有图标，遍历文件夹
fs.readdirSync(path.join(__dirname, "../source")).forEach((dir) => {
  // 子文件路径
  const dirPath = path.join(__dirname, "../source", dir);
  // 判断是否是文件夹，是则遍历文件
  if (fs.statSync(dirPath).isDirectory()) {
    // 遍历子文件夹
    fs.readdirSync(dirPath).forEach((file) => {
      // 文件路径
      const filePath = path.join(dirPath, file);
      // 使用 path.basename 获取 filePath 中的文件名，.svg 使用第二个参数来移除文件的扩展名。
      // 然后使用 toLowerCase 方法将文件名转换为小写，确保键名的一致性，便于后续的键值比较。
      const key = path.basename(filePath, ".svg").toLowerCase();

      if (ALL_ICON_MAP[key]) {
        console.log("图标名字重复：", key);
      }

      // 添加到map中，key为图标名字，value为【所在文件夹名字（分类），文件内容】
      ALL_ICON_MAP[key] = [dir, fs.readFileSync(filePath, "utf8")];
    });
  }
});

const data: IIconProps[] = [];
const categoryMap: Record<string, string> = {}; // 可以根据图标分类-EN找到图标分类-CN

// 首先使用 arr.slice(1) 来创建一个新的数组，该数组包含 arr 中从索引为 1 的元素开始的所有元素。
arr.slice(1).forEach((item: string[]) => {
  // 图标分类-EN => 图标分类-CN
  categoryMap[item[3]] = item[2];
});

// Name-CN,Name-EN,图标分类-CN,图标分类-EN,动效图标,图标预览,LTR,图标标签,UI 设计负责人
arr.slice(1).forEach((item: string[], i) => {
  const name = item[1]; // Name-EN
  let category = item[3]; // 图标分类-EN
  // source/[category]/[name].svg
  // 约定，db.csv的category和文件夹对应，name和文件名对应
  const filePath = path.resolve(__dirname, "../source", category, name + ".svg");
  const result = category + "/" + name;
  // 用于打印错误信息
  const printErrorMsg = (msg: string, data = result) => {
    console.log(msg, data);
    errors[result] = true;
  };

  let svg = "";

  // 校验，svg文件不存在
  if (!fs.existsSync(filePath)) {
    // svg文件不存在，ALL_ICON_MAP中存在name（source中有同名文件），=》路径不对=》分类不对
    if (ALL_ICON_MAP[name]) {
      svg = ALL_ICON_MAP[name][1]; // svg 文件内容，string
      printErrorMsg("svg分类错误: 请检查图标分类, 真实分类 = " + ALL_ICON_MAP[name][0]);
      // 更新内容，将分类改为真实分类
      const newItem = [...item];
      // 更新为source中的分类
      newItem[3] = ALL_ICON_MAP[name][0];
      newItem[2] = categoryMap[ALL_ICON_MAP[name][0]];
      NEW_CSV.push(newItem);
    } else {
      printErrorMsg("svg路径不存在: 请检查是否缺失svg或者拼写错误");
      return;
    }
  } else {
    // svg文件存在，读取文件内容
    svg = fs.readFileSync(filePath, "utf8");
    // 保存
    NEW_CSV.push(item);
  }

  // 删除ALL_ICON_MAP中的name，如果最后ALL_ICON_MAP中还有name，说明没有使用
  delete ALL_ICON_MAP[name];

  /**
   * 非法字符，
   * ^ 表示否定，即匹配除了后面指定的字符之外的任何字符。
   * \d 表示数字。
   * a-z 表示小写字母。
   * - 表示连字符。
   */
  if (/[^\da-z-]/.test(name)) {
    printErrorMsg("svg命名只允许小写字母/连字符/数字");
  }

  // 重复性, map中不存在name，添加到map中,避免重复覆盖
  if (!map[name]) {
    map[name] = true;
  } else {
    printErrorMsg("svg名字重复");
  }

  /**
     ! /^h[1-6]$/.test(name)：检查文件名 name 是否不符合以 h 开头，后跟 1 到 6 之间的数字的模式。这部分条件语句使用正则表达式 /^h[1-6]$/ 进行匹配。^ 表示字符串的开始位置，h 表示字符 h，[1-6] 表示数字 1 到 6 中的任意一个。test() 方法检查 name 是否匹配这个正则表达式。! 表示逻辑反，因此这部分条件语句的意思是，如果文件名 name 不以 h1 到 h6 开头，那么这个条件就不满足。
     /\d/g.test(name)：检查文件名 name 是否包含数字。这部分条件语句使用正则表达式 /\d/g 进行匹配。\d 表示数字字符，g 表示全局匹配模式，即检查整个字符串是否包含数字。test(name) 方法检查 name 是否匹配这个正则表达式。如果文件名 name 包含数字，那么这个条件就满足。
     总的来说，这段代码检查文件名 name 是否符合两个条件：不以 h1 到 h6 开头，并且包含数字。如果两个条件都满足，那么代码块就会执行，调用 printErrorMsg 方法
     */
  if (!/^h[1-6]$/.test(name) && /\d/g.test(name)) {
    printErrorMsg("svg命名出现数字（数字不表意，不推荐)");
  }

  // 数量+1
  count = count + 1;

  data.push({
    id: i,
    title: item[0],
    name,
    category,
    categoryCN: item[2],
    author: item[8].replace(/[,， ]+/g, ""),
    tag: item[7].split(/[,， ]+/).filter((item) => item.trim()),
    rtl: item[6].trim() === "是",
    svg,
  });
});

console.log("总图标数", count);
console.log("错误图标数", Object.keys(errors).length);

// 没使用图标，source中有，db.csv中没有
if (Object.keys(ALL_ICON_MAP).length) {
  console.log("没使用图标");
  Object.keys(ALL_ICON_MAP).forEach((key) => {
    console.log("Category = " + ALL_ICON_MAP[key][0] + " Name = " + key);
  });
}

// 将data写入icons.json文件
fs.writeFileSync(
  path.resolve(__dirname, "../source/icons.json"),
  JSON.stringify(data, null, 4),
  "utf8"
);

// 删除svg字段
data.forEach((item) => delete item.svg);

// 将data写入icons-config.json文件
fs.writeFileSync(
  path.resolve(__dirname, "../source/icons-config.json"),
  JSON.stringify(data, null, 4),
  "utf8"
);

// 将NEW_CSV写入db-fixed.csv文件，更新后的csv文件
fs.writeFileSync(path.resolve(__dirname, "../source/db-fixed.csv"), csv(NEW_CSV), "utf8");
```

### build/build-code.ts

> 处理 svg 文件，生成 Icon 代码文件，核心为@icon-park/compiler

**输入**：source/icons.json

**输出**：packages/react/src/icons, packages/vue/src/icons, packages/vue-next/src/icons, packages/svg/src/icons

```typescript
/**
 * @file build-code
 */

import { IconCompiler, IIconToolsOptions } from "@icon-park/compiler";
import fs from "fs";
import p from "path";
import mkdirp from "mkdirp";
import icons from "../source/icons.json";

export const BUILD_CONFIG: Omit<IIconToolsOptions, "type"> = {
  // ...... 省略
};

export const SUPPORT_PLATFORMS: ["react", "vue", "svg"] = ["react", "vue", "svg"];

SUPPORT_PLATFORMS.forEach((type) => {
  // 创建编译器
  const compiler = IconCompiler.instance({
    ...BUILD_CONFIG,
    type,
  });

  icons.forEach((item) =>
    compiler.appendIcon({
      name: item.name,
      description: item.title,
      content: item.svg,
      rtl: item.rtl,
    })
  );

  // 获取图标文件
  /**
   * {
   mime: 'image/svg+xml',
   path: `icons/${pascalCase(name)}.${useType ? 'ts' : 'js'}${isSvg ? '' : 'x'}`,
   content: svg
   }
   */
  const files = compiler.getIconFiles();

  files.forEach(({ path, content }) => {
    // 写入对应文件
    const fp = p.join(__dirname, "../packages", type, "src", path);
    // 创建文件夹
    mkdirp.sync(p.dirname(fp));
    // 写入文件
    fs.writeFileSync(fp, content, "utf8");
  });
});
```

通过代码可看出大致流程如下

1. 创建编译器，`IconCompiler.instance()`
2. 遍历 icons，添加图标,`compiler.appendIcon()`
3. 获取图标文件 List, `compiler.getIconFiles()`
4. 写入文件, `fs.writeFileSync()`
5. 最后生成文件包括：packages/vue/src/map.ts；packages/vue/src/runtime/index.tsx；packages/vue/src/icons/\*

因此下一步就是看`@icon-park/compiler`的实现，看看`IconCompiler`是如何实现将 svg 文件转换为 Icon 代码文件的。

## @icon-park/compiler

> 源码见 IconSpace 中

### 目录结构

```shell
.
├── LICENSE
├── sidebar.ts
├── package.json
└── src
    ├── Generator.ts
    ├── IconCompiler.ts # 1
    ├── Parser.ts
    ├── Transformer.ts
    ├── compiler.ts
    ├── generator
    │   ├── IconGenerator.ts
    │   ├── IndexGenerator.ts
    │   ├── JSXGenerator.ts
    │   ├── LessGenerator.ts
    │   ├── ReactRuntimeGenerator.ts
    │   ├── RuntimeGenerator.ts
    │   ├── SvgGenerator.ts
    │   ├── SvgRuntimeGenerator.ts
    │   ├── VueNextRuntimeGenerator.ts
    │   └── VueRuntimeGenerator.ts
    ├── sidebar.ts
    ├── tokenize.ts
    ├── transformer
    │   ├── CamelTransformer.ts
    │   ├── DynamicColorTransformer.ts
    │   ├── DynamicHueTransformer.ts
    │   ├── DynamicSizeTransformer.ts
    │   ├── DynamicStrokeTransformer.ts
    │   ├── FixMaskTypeTransformer.ts
    │   ├── GetIdTransformer.ts
    │   ├── GetKeyframesIdTransformer.ts
    │   ├── RemoveCSSPrefixTransformer.ts
    │   ├── RemoveConditionTransformer.ts
    │   ├── RemoveDataAttrTransformer.ts
    │   ├── RemoveIdTransformer.ts
    │   ├── RemovePropsTransformer.ts
    │   ├── RemoveTagsTransformer.ts
    │   ├── ReplaceIdTransformer.ts
    │   ├── ReplaceKeyframesIdTransformer.ts
    │   ├── SyncGroupProps.ts
    │   ├── UniqueIdTransformer.ts
    │   └── UniqueKeyframesIdTransformer.ts
    ├── types.ts
    └── util.ts
```

1、根据编译过程，从 IconCompiler 开始，查看 IconCompiler 的实现。

```ts
// src/IconCompiler.ts

import fs from "fs";
import path from "path";
import { compiler } from "./compiler";
import { IndexGenerator } from "./generator/IndexGenerator";
import { LessGenerator } from "./generator/LessGenerator";
import { ReactRuntimeGenerator } from "./generator/ReactRuntimeGenerator";
import { SvgRuntimeGenerator } from "./generator/SvgRuntimeGenerator";
import { VueRuntimeGenerator } from "./generator/VueRuntimeGenerator";
import { VueNextRuntimeGenerator } from "./generator/VueNextRuntimeGenerator";
import { pascalCase } from "./util";

import { DynamicColorTransformer } from "./transformer/DynamicColorTransformer";
import { RemoveConditionTransformer } from "./transformer/RemoveConditionTransformer";
import { RemoveTagsTransformer } from "./transformer/RemoveTagsTransformer";
import { RemovePropsTransformer } from "./transformer/RemovePropsTransformer";
import { RemoveDataAttrTransformer } from "./transformer/RemoveDataAttrTransformer";
import { DynamicSizeTransformer } from "./transformer/DynamicSizeTransformer";
import { DynamicStrokeTransformer } from "./transformer/DynamicStrokeTransformer";
import { UniqueIdTransformer } from "./transformer/UniqueIdTransformer";
import { UniqueKeyframesIdTransformer } from "./transformer/UniqueKeyframesIdTransformer";
import { RemoveCSSPrefixTransformer } from "./transformer/RemoveCSSPrefixTransformer";
import { CamelTransformer } from "./transformer/CamelTransformer";
import { DynamicHueTransformer } from "./transformer/DynamicHueTransformer";
import { SyncGroupProps } from "./transformer/SyncGroupProps";
import { ITransformPlugin } from "./Transformer";

import {
  IIconColorHueInfo,
  IIconColorReplaceInfo,
  IRuntimeGeneratorOptions,
  IRuntimeOptions,
} from "./generator/RuntimeGenerator";
import { IconGenerator } from "./generator/IconGenerator";
import { JSXGenerator } from "./generator/JSXGenerator";
import { SvgGenerator } from "./generator/SvgGenerator";
import { FixMaskTypeTransformer } from "./transformer/FixMaskTypeTransformer";

export interface IIconToolsOptions extends IRuntimeOptions {
  author: string;
  type: "react" | "vue" | "svg" | "vue-next";
}

export type IconCompilerFunc = (info: IIconInfo) => string;

export interface IIconFile {
  path: string;
  mime: string;
  content: string;
}

export interface IIconInfo {
  name: string;
  content: string;
  description?: string;
  rtl?: boolean;
}

export class IconCompiler {
  // 静态方法，创建IconCompiler实例
  public static instance(options: IIconToolsOptions): IconCompiler {
    return new IconCompiler(options);
  }

  // 保存用户传入的配置
  private readonly options: IIconToolsOptions;
  // map 存储一些内容
  private readonly map: Record<string, string> = {};
  // compiler
  private readonly compiler: IconCompilerFunc;
  // runtimeCode
  private readonly runtimeCode: string;

  // 1、构造函数
  private constructor(options: IIconToolsOptions) {
    this.options = options; // 保存用户传入的配置
    this.compiler = this.createCompiler(); // 初始化compiler，返回一个函数
    this.runtimeCode = this.createRuntimeCode(); // 初始化runtimeCode
  }

  /**
   * 2、icon.json的遍历，编译生成代码
   * info：{
       name: item.name,
       description: item.title,
       content: item.svg,
       rtl: item.rtl
     }
   * @param info
   * 编译后的代码，保存到map中
   */
  public appendIcon(info: IIconInfo): void {
    this.map[info.name] = this.compiler(info);
  }

  public getIconCode(name: string): string {
    const svg = this.map[name];

    if (!this.map[name]) {
      throw new Error("call `this.appendIcon(" + name + ")` first");
    }

    return svg;
  }

  public getIconFile(name: string): IIconFile {
    const svg = this.getIconCode(name);
    const { type, useType } = this.options;
    const isSvg = type === "svg";

    return {
      mime: "image/svg+xml",
      path: `icons/${pascalCase(name)}.${useType ? "ts" : "js"}${isSvg ? "" : "x"}`,
      content: svg,
    };
  }

  // 3、获取处理完的内容
  public getIconFiles(): IIconFile[] {
    const list = Object.keys(this.map).map((key) => this.getIconFile(key));

    list.push(this.getMapFile());

    return list;
  }

  // 返回一个对象
  public getMapFile(): IIconFile {
    return {
      mime: "text/javascript",
      path: "map." + (this.options.useType ? "ts" : "js"),
      content: this.getIndexCode(),
    };
  }

  // 生成packages/vue/src/map.ts文件
  public getIndexCode(): string {
    const { author, useType = false } = this.options;

    const generator = new IndexGenerator({
      name: "index",
      author,
      nameDisplayType: "camel",
      description: "引用出口",
      useType,
      icons: Object.keys(this.map),
    });

    return generator.process();
  }

  //
  private createCompiler(): IconCompilerFunc {
    // 获取用户传入的配置内容
    const {
      options: {
        type,
        colors = [],
        stroke = 0,
        fixedSize = false,
        style = false,
        strokeLinecap,
        strokeLinejoin,
      },
    } = this;

    // 将颜色分为两类，一类是hue，一类是replace
    const hueList: IIconColorHueInfo[] = [];
    const replaceList: IIconColorReplaceInfo[] = [];

    colors.forEach((item) => {
      if (item.type === "hue") {
        hueList.push(item);
      } else {
        replaceList.push(item);
      }
    });
    // type: 'react' | 'vue' | 'svg' | 'vue-next'
    const isSvg = type === "svg";

    // 返回一个函数，
    return ({ name, content, description = name, rtl = false }) => {
      // 保存一些插件
      const plugins: ITransformPlugin[] = [];

      // 删除无用的标签
      plugins.push(RemoveTagsTransformer({ tags: ["title", "desc", "a", "metadata"] }));
      // 删除掉无用的属性（当生成目标是react时，xmlns无效）
      // 修复mask-type属性的错误
      // data开头的属性无用
      // 增加动态颜色替换，一定要在Hue替换之前
      // 增加动态颜色替换
      // 删除多余的ID
      // 处理CSS动画
      // size处理
      // 处理描边
      // 处理额外增加的Rect
      // React需要进行变量名升级

      // 生成代码，根据type生成不同的代码
      let generator: IconGenerator =
        type === "vue"
          ? this.createVueGenerator(name, description, rtl)
          : type === "vue-next"
          ? this.createVueNextGenerator(name, description, rtl)
          : type === "react"
          ? this.createReactGenerator(name, description, rtl)
          : this.createSvgGenerator(name, description);

      // compiler编译函数，处理svg文件
      return compiler({
        content, // svg文件内容
        plugins, // 插件
        generator, // 生成器
      });
    };
  }

  private createSvgGenerator(name: string, description: string): SvgGenerator {
    const { author, style = false, prefix = "icon", useType = false } = this.options;

    return new SvgGenerator({
      name,
      author,
      nameDisplayType: "pascal",
      useDefault: true,
      useType,
      style,
      prefix,
      wrapperNeedName: true,
      wrapperNeedRTL: false,
      description,
      rtl: false,
      importPath: "../runtime",
    });
  }

  private createReactGenerator(name: string, description: string, rtl: boolean): JSXGenerator {
    /** ... */
  }

  private createVueGenerator(name: string, description: string, rtl: boolean): JSXGenerator {
    /** ... */
  }

  private createVueNextGenerator(name: string, description: string, rtl: boolean): JSXGenerator {
    const { author, style = false, prefix = "icon", useType = false } = this.options;

    return new JSXGenerator({
      name,
      author,
      rtl,
      prefix,
      nameDisplayType: "pascal",
      useDefault: true,
      useType,
      useHelper: false,
      wrapperNeedName: true,
      wrapperNeedRTL: true,
      style,
      description,
      importPath: "../runtime",
    });
  }

  // 生成runtime代码
  /**
   * packages/vue/src/runtime/index.tsx
   * packages/vue-next/src/runtime/index.tsx
   * packages/svg/src/runtime/index.tsx
   * packages/react/src/runtime/index.tsx
   */
  private createRuntimeCode(): string {
    // 获取用户传入的配置内容
    const {
      author,
      type,
      colors = [],
      prefix = "icon",
      stroke = 0,
      theme = [],
      fixedSize = false,
      style = false,
      cssPrefix = "sit",
      strokeLinecap,
      strokeLinejoin,
      useType = false,
    } = this.options;
    // baseOptions
    const baseOptions: IRuntimeGeneratorOptions = {
      name: "runtime",
      author,
      nameDisplayType: "camel",
      description: "运行时",
      useType,
      colors,
      prefix,
      cssPrefix,
      stroke,
      theme,
      fixedSize,
      style,
      strokeLinecap,
      strokeLinejoin,
      wrapperNeedName: true,
    };
    // 根据type生成不同的代码
    const generator =
      type === "vue"
        ? new VueRuntimeGenerator({
            ...baseOptions,
            wrapperNeedRTL: true,
          })
        : type === "vue-next"
        ? new VueNextRuntimeGenerator({
            ...baseOptions,
            wrapperNeedRTL: true,
          })
        : type === "react"
        ? new ReactRuntimeGenerator({
            ...baseOptions,
            wrapperNeedRTL: true,
          })
        : new SvgRuntimeGenerator({
            ...baseOptions,
          });

    // process()方法返回的是代码文本
    return generator.process();
  }
}
```

### VueNextRuntimeGenerator

> ./generator/VueNextRuntimeGenerator
>
> `new VueNextRuntimeGenerator({ ...baseOptions, wrapperNeedRTL: true })`

:::code-group

```ts [VueNextRuntimeGenerator.ts]
import { RuntimeGenerator } from "./RuntimeGenerator";

// VueNextRuntimeGenerator 发现没有构造函数，执行父类的构造函数
export class VueNextRuntimeGenerator extends RuntimeGenerator {
  protected processPlatformImports(): void {
    // true
    if (this.useType) {
      this.writeLine(
        "import {ComponentOptions, DefineComponent, inject, provide} from '@vue/runtime-dom';"
      );
      this.writeLine();
    }

    this.writeLine();
  }

  protected processPlatformTypes(): void {
    this.writeLine("// 包裹后的图标属性");
  }

  // eslint-disable-next-line @typescript-eslint/no-empty-function
  protected processPlatformCode(): void {}

  protected processPlatformWrapper(): void {}
}
```

```ts [RuntimeGenerator.ts]
import { Generator, IGeneratorOptions } from "../Generator";
import { camelCase, pascalCase } from "../util";

//
export abstract class RuntimeGenerator extends Generator {
  protected useType: boolean;

  protected colors: IIconColorInfo[];

  protected stroke: number;

  protected cssPrefix: string;

  protected theme: IIconThemeInfo[];

  protected fixedSize: boolean;

  protected style: boolean;
  protected wrapperNeedName: boolean;
  protected wrapperNeedRTL: boolean;

  protected hueList: IIconColorHueInfo[] = [];

  protected replaceList: IIconColorReplaceInfo[] = [];

  protected hasDefaultTheme: boolean;

  protected strokeLinecap?: StrokeLinecap;

  protected strokeLinejoin?: StrokeLinejoin;

  // 构造函数
  constructor(options: IRuntimeGeneratorOptions) {
    super(options);

    this.useType = options.useType || false;
    this.stroke = options.stroke || 0;
    this.cssPrefix = options.cssPrefix || "sit";
    this.theme = options.theme || [];
    this.fixedSize = options.fixedSize || false;
    this.style = options.style || false;
    this.colors = options.colors || [];
    this.strokeLinecap = options.strokeLinecap;
    this.strokeLinejoin = options.strokeLinejoin;
    this.wrapperNeedName = options.wrapperNeedName || false;
    this.wrapperNeedRTL = options.wrapperNeedRTL || false;

    this.colors.forEach((item) => {
      if (item.type === "hue") {
        this.hueList.push(item);
      } else {
        this.replaceList.push(item);
      }
    });

    this.hasDefaultTheme = this.theme.some((item) => item.fill.some((item) => item.name));
  }

  // 代码执行，返回值可以参考packages/vue/src/runtime/index.tsx
  public process(): string {
    // 生成头部的注释，父类Generator.ts的方法
    this.processHeaderComment();

    // 添加外部引用，子类中实现，写入一些类型文本
    this.processPlatformImports();

    if (this.useType) {
      // 定义常量类型，父类方法，写入一些文本
      this.processConstTypes();

      // 生成内部函数属性类型参数，写入一些文本
      this.processSvgType();

      // 生成配置信息类型，写入一些文本
      this.processConfigType();

      // 生成属性类型，写入一些文本
      this.processPropsType();

      // 生成平台外部类型，写入一些文本
      this.processPlatformTypes();
    }

    // 生成默认配置信息，写入一些文本
    this.processConfigData();

    // 生成工具函数
    /**
          function guid(): string {
            return 'icon-' + (((1 + Math.random()) * 0x100000000) | 0).toString(16).substring(1);
          }
        */
    this.processUtil();

    // 生成转换函数代码，写入一些文本
    this.processConverter();

    // 平台业务代码，子类中实现，vue-next中实现为空
    this.processPlatformCode();

    // 生成Wrapper代码，写入一些文本
    this.processWrapper();

    return this.getResult(); // 返回结果，即生成的代码文本
  }

  // abstract用于定义抽象类和其中的抽象方法。抽象类中的抽象方法必须被子类实现
  protected abstract processPlatformImports(): void;
  // abstract用于定义抽象类和其中的抽象方法。抽象类中的抽象方法必须被子类实现
  protected abstract processPlatformTypes(): void;
  // abstract用于定义抽象类和其中的抽象方法。抽象类中的抽象方法必须被子类实现
  protected abstract processPlatformCode(): void;
  // abstract用于定义抽象类和其中的抽象方法。抽象类中的抽象方法必须被子类实现
  protected abstract processPlatformWrapper(): void;

  protected processConstTypes(): void {}

  protected processSvgType(): void {
    const { replaceList, hueList } = this;
  }

  protected processConfigType(): void {
    this.writeLine();
  }

  protected processPropsType(): void {}

  protected processSvgCommonType(optional: boolean = false): void {
    const { fixedSize, stroke, strokeLinecap, strokeLinejoin } = this;
  }

  protected processConfigData(): void {
    const { cssPrefix, fixedSize, stroke, strokeLinejoin, strokeLinecap, useType, theme } = this;
  }

  protected processUtil(): void {
    this.writeLine(`function guid()${this.useType ? ": string" : ""} {`);
    this.indent(1);
    this.writeLine(
      `return '${this.prefix}-' + (((1 + Math.random()) * 0x100000000) | 0).toString(16).substring(1);`
    );
    this.indent(-1);
    this.writeLine("}");
    this.writeLine();
  }

  protected processConverter(): void {
    this.writeLine("// 属性转换函数");
  }

  protected processWrapper(): void {
    this.writeLine("// 图标Wrapper");
  }

  protected getPropKeys(): string[] {
    const arr: string[] = [];
    const { fixedSize, stroke, hueList, replaceList, strokeLinecap, strokeLinejoin } = this;

    if (fixedSize) {
      arr.push("size");
    } else {
      arr.push("width", "height");
    }

    if (stroke) {
      arr.push("strokeWidth");
    }

    if (strokeLinecap) {
      arr.push("strokeLinecap");
    }

    if (strokeLinejoin) {
      arr.push("strokeLinejoin");
    }

    if (this.theme.length) {
      arr.push("theme");
    }

    if (hueList.length || replaceList.length) {
      arr.push("fill");
    }

    return arr;
  }

  protected getClassName(key?: string): string {
    const { cssPrefix, prefix } = this;
    return `'${cssPrefix}-${prefix}${key ? "-" + key : ""}'`;
  }

  protected getColorTypes(): string[] {
    // 添加类型
    const list: string[] = [];

    if (this.hueList.length) {
      list.push("HSL");
    }

    if (this.replaceList.length) {
      list.push("string");
    }

    if (list.length === 1) {
      list.push(list[0] + "[]");
    } else if (list.length > 1) {
      list.push(`Array<${list.join(" | ")}>`);
    }

    return list;
  }
}
```

```ts [Generator.ts]
import { ISvgInfo } from "./types";
import { camelCase, pascalCase } from "./util";

export interface IGeneratorOptions {
  author: string;
  name: string;
  nameDisplayType?: "origin" | "camel" | "pascal";
  description?: string;
  prefix?: string;
}

export class Generator {
  protected author: string;
  protected name: string;
  protected nameDisplayType: "origin" | "camel" | "pascal";
  protected description: string;
  protected result: string = "";
  protected indentSize: number = 0;
  protected isNewLine: boolean = true;
  protected prefix: string;

  constructor(options: IGeneratorOptions) {
    this.name = options.name;
    this.author = options.author;
    this.nameDisplayType = options.nameDisplayType || "origin";
    this.description = options.description || "";
    this.prefix = options.prefix || "icon";
  }

  public process(info: ISvgInfo): string {
    throw new Error("method must be override");
  }

  // 获取处理结果
  protected getResult(): string {
    return this.result;
  }

  // 生成顶部注释
  /**
   * @file [Abdominal] [腹部]
   * @author Auto Generated by [IconPark]
   */
  protected processHeaderComment(): void {
    const { name, author, nameDisplayType } = this;
    const displayName =
      nameDisplayType === "pascal"
        ? pascalCase(name)
        : nameDisplayType === "camel"
        ? camelCase(name)
        : name;
    // writeLine方法是写一行代码，如果不传参数，就是写一个空行
    this.writeLine("/**");
    this.writeLine(" * @file " + displayName + " " + this.description);
    this.writeLine(" * @author Auto Generated by " + author);
    this.writeLine(" */");
    this.writeLine("");
  }

  // 写一个空格
  protected space(): void {
    if (this.isNewLine) {
      this.result += " ".repeat(this.indentSize * 4);
      this.isNewLine = false;
    }

    this.result += " ";
  }

  // 写一行代码
  protected writeLine(word?: string): void {
    // 如果不传参数，就是写一个换行
    if (!word) {
      this.result += "\n";
      this.isNewLine = true;
      return;
    }
    // 写一行代码, 并且换行
    this.write(word);
    this.result += "\n";
    this.isNewLine = true;
  }

  // 写一部分代码
  protected write(word: string): void {
    if (this.isNewLine) {
      this.result += " ".repeat(this.indentSize * 4);
      this.isNewLine = false;
    }
    this.result += word;
  }

  // 添加缩进
  protected indent(size: number): void {
    this.indentSize = Math.max(this.indentSize + size, 0);
  }

  protected getInterfaceName(type: string, isSvg: boolean = false): string {
    return "I" + this.getTypeName(type, isSvg);
  }

  protected getTypeName(type: string, isSvg: boolean = false): string {
    const { prefix } = this;
    return `${isSvg ? "Svg" : ""}${pascalCase(prefix)}${type ? pascalCase(type) : ""}`;
  }
}
```

```ts [IconGenerator.ts]
import { Generator, IGeneratorOptions } from "../Generator";
import { pascalCase } from "../util";

export class IndexGenerator extends Generator {
  protected useType: boolean;

  protected icons: string[];

  constructor(options: IIndexGeneratorOptions) {
    super(options);

    this.useType = options.useType || false;
    this.icons = options.icons;
  }

  public process(): string {
    // 写头部的注释
    this.processHeaderComment();

    this.icons.forEach((name) => {
      this.writeLine(`export {default as ${pascalCase(name)}} from './icons/${pascalCase(name)}';`);
    });

    return this.getResult();
  }
}
```

:::

## 相关阅读

[图标组件库学习一.md](%E5%9B%BE%E6%A0%87%E7%BB%84%E4%BB%B6%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B8%80.md)
[图标组件库学习二.md](%E5%9B%BE%E6%A0%87%E7%BB%84%E4%BB%B6%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%BA%8C.md)
[图标组件库学习三.md](%E5%9B%BE%E6%A0%87%E7%BB%84%E4%BB%B6%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B8%89.md)
